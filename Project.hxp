package;

import hxp.*;
import lime.tools.*;
import sys.io.Process;

using StringTools;

/**
 * This is the main project file for TechNotDrip Engine.
 *
 * This works exactly like an Project.xml but in Haxe Syntax.
 */
class Project extends HXProject
{
	/**
	 * The version of TechNotDrip Engine.
	 */
	public final TECHNOTDRIP_VERSION:String = '0.1.0';

	/**
	 * `-DDOX_GENERATION`
	 * Whether the game should be compiled into dox instead.
	 * Developers can set this by checking the flag above.
	 */
	public final DOX_GENERATION:FeatureFlag = "DOX_GENERATION";

	/**
	 * `-DSHOW_GIT`
	 * Whether the git hashes/branches should be shown in MenuState.
	 * Developers can set this by checking the flag above.
	 */
	public final SHOW_GIT:FeatureFlag = "SHOW_GIT";

	public var GIT_HASH:String = null;

	public var GIT_BRANCH:String = null;

	public var GIT_MODIFIED:Null<Bool> = null;

	public function new()
	{
		super();

		setenv('HAXEPATH', './'); // Fixes an issue for haxelibs that use native C++ files until Haxe 5 releases.

		setupApplicationSettings();
		setupWindowSettings();
		setupPathSettings();
		setupFeatureFlags();
		setupHaxelibs();
		setupHaxeDefines();
		setupHaxeFlags();
	}

	public function setupApplicationSettings():Void
	{
		meta.title = 'Friday Night Funkin\': TechNotDrip Engine';
		meta.version = TECHNOTDRIP_VERSION;
		meta.packageName = 'com.technotdrip.tilnotdrip';
		meta.company = 'TilNotDrip';

		app.file = 'TechNotDrip';
		app.main = 'Main';
		app.preloader = 'flixel.system.FlxPreloader';
	}

	public function setupWindowSettings():Void
	{
		window.width = 1280;
		window.height = 720;
		window.background = 0;
		window.hardware = true;
		window.vsync = false;

		if (platformType == WEB)
		{
			window.resizable = true;
		}

		if (platformType == DESKTOP)
		{
			window.orientation = LANDSCAPE;
			window.fullscreen = false;
			window.resizable = true;
		}

		if (platformType == MOBILE)
		{
			window.orientation = LANDSCAPE;
			window.fullscreen = false;
			window.resizable = false;
			window.width = 0;
			window.height = 0;
		}
	}

	public function setupPathSettings():Void
	{
		app.path = 'export/' + ((debug) ? 'debug' : 'release');

		var excludeList:Array<String> = [];
		excludeList.push((platformType == WEB) ? 'ogg' : 'mp3');

		// TODO: Maybe scan the entire assets folder instead like base fnf.
		includeAssets("assets", "assets", ['*'], excludeList);

		addIcon('extras/appicons/icon16.png', 16);
		addIcon('extras/appicons/icon32.png', 32);
		addIcon('extras/appicons/icon64.png', 64);
		addIcon('extras/appicons/icon.png');

		sources.push('src');
	}

	public function setupFeatureFlags():Void
	{
		// The second parameter is the default value unless overridden!
		DOX_GENERATION.apply(this, false); // Will always be false unless you wanna make a documentation website.
		SHOW_GIT.apply(this, !['stable', 'main', 'master', null].contains(getGitBranch().toLowerCase())); // Will show if it isn't the main branch!
	}

	public function setupHaxelibs():Void
	{
		addHaxelib('lime', '8.2.1');
		addHaxelib('openfl', '9.4.0');
		addHaxelib('flixel', '5.8.0');
		addHaxelib('flixel-addons', '3.2.3');
		addHaxelib('flxanimate', 'git');
		addHaxelib('hxcpp-debug-server', '1.2.4', debug);
	}

	public function setupHaxeDefines():Void
	{
		addHaxeDefine('doc-gen', DOX_GENERATION.isEnabled(this));
		addHaxeDefine('FLX_NO_DEBUG', !debug);
		addHaxeDefine('FLX_NO_FOCUS_LOST_SCREEN');
		addHaxeDefine('FLX_NO_HEALTH');
		addHaxeDefine('FLX_NO_KEYBOARD', platformType == MOBILE);
		addHaxeDefine('FLX_NO_MOUSE', platformType == MOBILE);
		addHaxeDefine('FLX_NO_TOUCH', platformType != MOBILE);
		addHaxeDefine('message.reporting', 'pretty');
		addHaxeDefine('NAPE_RELEASE_BUILD', !debug);
		addHaxeDefine('TND_GIT_HASH', getGitHash(false));
		addHaxeDefine('TND_GIT_BRANCH', getGitBranch());
		addHaxeDefine('TND_GIT_MODIFIED', getGitModified());
	}

	public function setupHaxeFlags():Void
	{
		addHaxeFlag('-dce no');
		addHaxeFlag("--macro include('funkin')");
		addHaxeFlag("--macro include('flixel', true, ['flixel.addons.editors.spine.*', 'flixel.addons.nape.*', 'flixel.system.macros.*'])");
		addHaxeFlag("--macro addMetadata('@:build(funkin.macros.ZProperty.build())', 'flixel.FlxBasic')");
		addHaxeFlag('--no-output', DOX_GENERATION.isEnabled(this));
		addHaxeFlag('-xml docs/dox/' + Std.string(target).toLowerCase() + '.xml', DOX_GENERATION.isEnabled(this));
	}

	public function addHaxelib(name:String, version:String = '', conditions:Bool = true):Void
	{
		if (!conditions)
			return;

		haxelibs.push(new Haxelib(name, version));
	}

	public function addHaxeDefine(name:String, value:String = '', conditions:Bool = true):Void
	{
		if (!conditions)
			return;

		haxedefs.set(name, value);
	}

	public function addHaxeFlag(name:String, conditions:Bool = true):Void
	{
		if (!conditions)
			return;

		haxeflags.push(name);
	}

	public function addIcon(path:String, ?size:Int):Void
	{
		icons.push(new Icon(path, size));
	}

	function getGitHash(splice:Bool = false):String
	{
		if (GIT_HASH == null)
		{
			var gitProcess:Process = new Process('git', ['rev-parse', 'HEAD']);

			if (gitProcess.exitCode() != 0)
			{
				trace('[WARNING]: Unable to get current git repository hash.');
				return null;
			}
			else
			{
				GIT_HASH = gitProcess.stdout.readLine().trim();
			}

			gitProcess.close();
		}

		return GIT_HASH;
	}

	function getGitBranch():String
	{
		if (GIT_BRANCH == null)
		{
			var gitProcess:Process = new Process('git', ['rev-parse', '--abbrev-ref', 'HEAD']);

			if (gitProcess.exitCode() != 0)
			{
				trace('[WARNING]: Unable to get current git repository branch.');
				return null;
			}
			else
			{
				GIT_BRANCH = gitProcess.stdout.readLine().trim();
			}

			gitProcess.close();
		}

		return GIT_BRANCH;
	}

	function getGitModified():Bool
	{
		if (GIT_MODIFIED == null)
		{
			var gitProcess:Process = new Process('git', ['status', '--porcelain']);

			if (gitProcess.exitCode() != 0)
			{
				trace('[WARNING]: Unable to get current git repository branch.');
				return null;
			}
			else
			{
				try
				{
					GIT_MODIFIED = gitProcess.stdout.readLine().trim().length > 0;
				}
				catch(e)
				{
					return false; // idk it breaks sometimes
				}
			}

			gitProcess.close();
		}

		return GIT_MODIFIED;
	}
}

/**
 * An object representing a feature flag, which can be enabled or disabled.
 * Includes features such as automatic generation of compile defines and inversion.
 */
abstract FeatureFlag(String) {
	static final INVERSE_PREFIX:String = "NO_";

	public function new(input:String) {
		this = input;
	}

	@:from
	public static function fromString(input:String):FeatureFlag {
		return new FeatureFlag(input);
	}

	/**
	 * Enable/disable a feature flag if it is unset, and handle the inverse flag.
	 * Doesn't override a feature flag that was set explicitly.
	 * @param enableByDefault Whether to enable this feature flag if it is unset.
	 */
	public function apply(project:Project, enableByDefault:Bool = false):Void {
		// TODO: Name this function better?

		if (isEnabled(project)) {
			// If this flag was already enabled, disable the inverse.
			getInverse().disable(project, false);
		} else if (getInverse().isEnabled(project)) {
			// If the inverse flag was already enabled, disable this flag.
			disable(project, false);
		} else {
			if (enableByDefault) {
				// Enable this flag if it was unset, and disable the inverse.
				enable(project, true);
			} else {
				// Disable this flag if it was unset, and enable the inverse.
				disable(project, true);
			}
		}
	}

	/**
	 * Enable this feature flag by setting the appropriate compile define.
	 *
	 * @param project The project to modify.
	 * @param andInverse Also disable the feature flag's inverse.
	 */
	public function enable(project:Project, andInverse:Bool = true) {
		project.haxedefs.set(this, "");
		if (andInverse) {
			getInverse().disable(project, false);
		}
	}

	/**
	 * Disable this feature flag by removing the appropriate compile define.
	 *
	 * @param project The project to modify.
	 * @param andInverse Also enable the feature flag's inverse.
	 */
	public function disable(project:Project, andInverse:Bool = true) {
		project.haxedefs.remove(this);
		if (andInverse) {
			getInverse().enable(project, false);
		}
	}

	/**
	 * Query if this feature flag is enabled.
	 * @param project The project to query.
	 */
	public function isEnabled(project:Project):Bool {
		// Check both Haxedefs and Defines for this flag.
		return project.haxedefs.exists(this) || project.defines.exists(this);
	}

	/**
	 * Query if this feature flag's inverse is enabled.
	 */
	public function isDisabled(project:Project):Bool {
		return getInverse().isEnabled(project);
	}

	/**
	 * Return the inverse of this feature flag.
	 * @return A new feature flag that is the inverse of this one.
	 */
	public function getInverse():FeatureFlag {
		if (this.startsWith(INVERSE_PREFIX)) {
			return this.substring(INVERSE_PREFIX.length);
		}
		return INVERSE_PREFIX + this;
	}
}